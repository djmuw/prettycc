{"name":"Prettycc","tagline":"A small C++ library for formatted stream output of standard library objects","body":"# 0. Preface and wording\r\n\r\nA **'decoration'** in terms of this answer is a set of prefix-string, delimiter-string and a postfix-string.\r\nWhere the prefix string is inserted into a stream before and the postfix string after the values of a container (see 2. Target containers).\r\nThe delimiter string is inserted between the values of the respective container.\r\n\r\n*Note: Actually, this answer does not address the question to 100% since the decoration is not strictly compile time constant because runtime checks are required to check whether a custom decoration has been applied to the current stream.*\r\nNevertheless, I think it has some decent features.\r\n\r\n*Note2: May have minor bugs since it is not yet well tested.*\r\n\r\n# 1. General idea / usage\r\n\r\n### Zero additional code required for usage\r\n\r\nIt is to be kept as easy as\r\n\r\n    #include <vector>\r\n    #include \"pretty.h\"\r\n\r\n    int main()\r\n    {\r\n      std::cout << std::vector<int>{1,2,3,4,5}; // prints 1, 2, 3, 4, 5\r\n      return 0;\r\n    }\r\n\r\n### Easy customization ...\r\n\r\n... with respect to specific stream object\r\n\r\n    #include <vector>\r\n    #include \"pretty.h\"\r\n\r\n    int main()\r\n    {\r\n      // set decoration for std::vector<int> for cout object\r\n      std::cout << pretty::decoration<std::vector<int>>(\"(\", \",\", \")\");\r\n      std::cout << std::vector<int>{1,2,3,4,5}; // prints (1,2,3,4,5)\r\n      return 0;\r\n    }\r\n\r\nor with respect to all streams:\r\n\r\n    #include <vector>\r\n    #include \"pretty.h\"\r\n\r\n    // set decoration for std::vector<int> for all ostream objects\r\n    PRETTY_DEFAULT_DECORATION(std::vector<int>, \"{\", \", \", \"}\")\r\n\r\n    int main()\r\n    {\r\n      std::cout << std::vector<int>{1,2,3,4,5}; // prints {1, 2, 3, 4, 5}\r\n      std::cout << pretty::decoration<std::vector<int>>(\"(\", \",\", \")\");\r\n      std::cout << std::vector<int>{1,2,3,4,5}; // prints (1,2,3,4,5)\r\n      return 0;\r\n    }\r\n\r\n### Rough description\r\n\r\n- The code includes a class template providing a default decoration for any type\r\n- which can be specialized to change the default decoration for (a) certain type(s) and it is\r\n- using the private storage provided by `ios_base` using `xalloc`/`pword` in order to save a pointer to a `pretty::decor` object specifically decorating a certain type on a certain stream.\r\n\r\nIf no `pretty::decor<T>` object for this stream has been set up explicitly `pretty::defaulted<T, charT, chartraitT>::decoration()` is called to obtain the default decoration for the given type.\r\nThe class `pretty::defaulted` is to be specialized to customize default decorations.\r\n \r\n# 2. Target objects / containers\r\n\r\nTarget objects `obj` for the *'pretty decoration'* of this code are objects having either\r\n\r\n- overloads `std::begin` and `std::end` defined (includes C-Style arrays),\r\n- having `begin(obj)` and `end(obj)` available via ADL,\r\n- are of type `std::tuple` \r\n- or of type `std::pair`.\r\n\r\nThe code includes a trait for identification of classes with range features (`begin`/`end`).\r\n(There's no check included, whether `begin(obj) == end(obj)` is a valid expression, though.)\r\n \r\nThe code provides `operator<<`s in the global namespace that only apply for classes not having a more specialized version of `operator<<` available.\r\nTherefore, in example `std::string` is not printed using the operator in this code although having a valid `begin`/`end` pair.\r\n\r\n# 3. Utilization and customization\r\n\r\nDecorations can be imposed seperately for every type (except different `tuple`s) and stream (not stream type!).\r\n(I.e. a `std::vector<int>` can have a different decorations for different stream objects.)\r\n\r\n## A) Default decoration\r\n\r\nThe default prefix is `\"\"` (nothing) as is the default postfix, while the default delimiter is `\", \"` (comma+space).\r\n\r\n## B) Customized default decoration of a type by specializing the `pretty::defaulted` class template\r\n\r\nThe `struct defaulted` has a static member function `decoration()` returning a `decor` object which includes the default values for the given type.\r\n\r\n### Example using array:\r\n\r\nCutomize default array printing:\r\n\r\n    namespace pretty\r\n    {\r\n      template<class T, std::size_t N>\r\n      struct defaulted<T[N]>\r\n      {\r\n        static decor<T[N]> decoration()\r\n        {\r\n          return{ { \"(\" }, { \":\" }, { \")\" } };\r\n        }\r\n      };\r\n    }\r\n\r\nPrint an arry array:\r\n\r\n    float e[5] = { 3.4f, 4.3f, 5.2f, 1.1f, 22.2f };\r\n    std::cout << e << '\\n'; // prints (3.4:4.3:5.2:1.1:22.2)\r\n\r\n### Using the `PRETTY_DEFAULT_DECORATION(TYPE, PREFIX, DELIM, POSTFIX, ...)` macro for `char` streams\r\n\r\nThe macro expands to\r\n\r\n    namespace pretty { \r\n      template< __VA_ARGS__ >\r\n      struct defaulted< TYPE > {\r\n        static decor< TYPE > decoration() {\r\n          return { PREFIX, DELIM, POSTFIX };\r\n        } \r\n      }; \r\n    } \r\n\r\nenabling the above partial specialization to be rewritten to\r\n\r\n    PRETTY_DEFAULT_DECORATION(T[N], \"\", \";\", \"\", class T, std::size_t N)\r\n\r\nor inserting a full specialization like\r\n\r\n    PRETTY_DEFAULT_DECORATION(std::vector<int>, \"(\", \", \", \")\")\r\n\r\nAnother macro for `wchar_t` streams is included: `PRETTY_DEFAULT_WDECORATION`.\r\n\r\n## C) Impose decoration on streams\r\n\r\nThe function `pretty::decoration` is used to impose a decoration on a certain stream.\r\nThere are overloads taking either \r\n- one string argument being the delimiter (adopting prefix and postfix from the defaulted class)\r\n- or three string arguments assembling the complete decoration\r\n\r\n### Complete decoration for given type and stream\r\n\r\n    float e[3] = { 3.4f, 4.3f, 5.2f };\r\n    std::stringstream u;\r\n    // add { ; } decoration to u\r\n    u << pretty::decoration<float[3]>(\"{\", \"; \", \"}\");\r\n \r\n    // use { ; } decoration\r\n    u << e << '\\n'; // prints {3.4; 4.3; 5.2}\r\n\r\n    // uses decoration returned by defaulted<float[3]>::decoration()\r\n    std::cout << e; // prints 3.4, 4.3, 5.2\r\n\r\n### Customization of delimiter for given stream\r\n\r\n    PRETTY_DEFAULT_DECORATION(float[3], \"{{{\", \",\", \"}}}\")\r\n\r\n    std::stringstream v;\r\n    v << e; // prints {{{3.4,4.3,5.2}}}\r\n\r\n    v << pretty::decoration<float[3]>(\":\");\r\n    v << e; // prints {{{3.4:4.3:5.2}}}\r\n\r\n    v << pretty::decoration<float[3]>(\"((\", \"=\", \"))\");\r\n    v << e; // prints ((3.4=4.3=5.2))\r\n\r\n\r\n# 4. Special handling of `std::tuple`\r\n\r\nInstead of allowing a specialization for every possible tuple type, this code applies any decoration available for `std::tuple<void*>` to all kind of `std::tuple<...>`s.\r\n\r\n# 5. Remove custom decoration from stream\r\n\r\nTo go back to the defaulted decoration for a given type use `pretty::clear` function template on the stream `s`.\r\n\r\n    s << pretty::clear<std::vector<int>>();\r\n\r\n# 5. Further examples\r\n\r\nPrinting \"matrix-like\" with newline delimiter\r\n\r\n    std::vector<std::vector<int>> m{ {1,2,3}, {4,5,6}, {7,8,9} };\r\n    std::cout << pretty::decoration<std::vector<std::vector<int>>>(\"\\n\");\r\n    std::cout << m;\r\n\r\nPrints\r\n\r\n    1, 2, 3\r\n    4, 5, 6\r\n    7, 8, 9","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}